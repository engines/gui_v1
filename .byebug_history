q
"".empty?
"".present?
nil||1
0||1
""||1
status.exitstatus
stdout
stderr
command
c
command
stdout
stderr
c
status.exitstatus
puts status.methods
status.success?
c
status.success?
stderr
c
stdout
q
@message
c
puts status.methods
status.code
status.exit
status
c
`git -C '#{ path }' commit -m #{ commit[:message] }`
c
params
c
params
c
params
params[:type]
q
type
q
c
entry_path
c
entry_path
c
entry_path
c
entry_path
c
entry_path
c
entry_path.sub( path, '' ).sub( '.yaml', '' )
File.read( entry_path )
entry_path
c
Dir.glob( "#{ path }/**/*.yaml" )
puts Dir.glob( "#{ path }/**/*.yaml" )
Dir.glob( "#{ path }/**/*.yaml" )
c
q
Dir.glob( "#{ path }/**" )
c
Dir.glob( "#{ path }/*" )
q
data_dir
q
Dir.glob( "#{ path }/*" )
path
c
path
q
namespace.services.to_h
namespace.services
q
owner.project_dir
owner.repo_dir
q
owner.path
c
owner.path
c
owner.path
q
owner
owner.path
"#{ owner.path }/#{ owner.name }"
c
"#{ owner.path }/#{ owner.name }"
c
"#{ owner.path }/#{ owner.name }"
owner
c
project_dir
c
q
c
params
q
project_dir
q
puts settings.methods.sort
settings.methods.sort
settings.methods
settings
quit
request.body.read
request.body
params
quit
params
quit
params
quit
params[:blueprint]
params
exit
ENV['SESSION_TIMEOUT_MINUTES']
c
Home.new.to_json
c
 @engines.get( "/containers/#{ typeForRoute }/#{ name }/status" ).body
 @engines.get( "/containers/#{ typeForRoute }/#{ name }/status" )
statusJSON
c
e
c
JSON.parse( '{"status":"untag","id":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf","Type":"container","Action":"untag","Actor":{"ID":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf","Attributes":{"name":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf"}},"time":1575164190,"timeNano":1575164190353597993,"container_name":null,"container_type":null,"state":"untag"}' )
e
c
puts JSON.pretty_generate params[:api_vars]
c
puts JSON.pretty_generate params[:api_vars]
puts params[:api_vars].to_yaml
c
puts params[:api_vars].to_yaml
params[:api_vars]
c
params[:api_vars]
c
puts params[:api_vars].to_yaml
puts params[:api_vars]
params[:api_vars]
c
params
c
puts JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body )
e.http_body
e.response.message
e.response
c
e.class
e.is_a? RestClient
e.is_as? RestClient
e
c
e.message
e
ee
e
q
JSON.parse( e.http_body ).to_yaml
puts JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body )
e.http_body
e.http_headers
e.http_body
puts e.methods.sort
e.http_code.class
e.http_code
puts e.http_code
puts e.methods.sort
e.response.http_statu
e.response.http_status
e.response.status
e.response.headers
JSON.parse( e.response.body )
e.response.headers[:content_type]
e.response.headers
e.response[:headers]
e.response.body
puts e.response.methods.sort
puts e.methods.response.sort
e.response
e.to_json
puts e.methods.sort
e.message
e.class
e
c
e
c
q
c
@current_user
c
to_h.each_with_index.select { |view,i| view[:name] == name }.map(&:last)[0]
to_h.each_with_index.select { |view,i| view[:name] == name }.map &:last
c
to_h[1]['name']
to_h[1][:name]
to_h[1]
to_h.find do |view| view[:name]  end
to_h.find do |view| view[:name] == name end
to_h
c
id
path
project_dir
c
Application.active
Service.active
Service.count
Namespace.to_h
            }Namespace.to_h
              # git_user: @settings.git_username
              namespaces: Namespace.to_h,
              },
                active: Service.active,
                count: Service.count,
              services: {
              },
                active: Application.active,
                count: Application.count,
              applications: {
              public_key: @current_user.public_key,
{
Application.count
@current_user.public_key
c
params
c
status
status = 'Up to date' if status == ''
`git -C '#{ path }' status -s`
c
status
c
name
namespace ? "#{ namespace }/#{ name }" : name
namespace
c
"#{ destination }/#{ id }"
c
"#{ destination }/#{ id }"
c
"#{ destination }/#{ id }"
id
destination
c
puts caller(0)
params
