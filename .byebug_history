c
@engines.get('/system/keys/user/engines/generate').body
c
@engines.get('/system/keys/user/engines/generate').body
@engines.get('/system/keys/user/engines/generate')
q
c
e
c
request.path_info == '/reconnected' && request.request_method == 'GET'
c
request.path_info == '/session' && request.request_method == 'POST'
request.path_info
c
puts e.full_message
e.full_message
e
c
e
c
q
puts e.full_message
e.full_message
e.methods
e.class
e
c
api_call( route, method: :post, **options )
options
q
request.content_length
request.content_type
request.body
puts request.to_yaml
request
params
q
params
request.content_type
request
params
c
params
c
params
puts self.methods.sort
self.methods
self
query
params.to_json
params
@engines.delete(path)
q
@engines.delete(path, '{}')
@engines.delete(path)
q
@engines.delete(path, '{}')
@engines.delete(path)
params.to_json
c
puts request.to_yaml
puts request.methods.sort
request.methods
request
c
JSON.parse( @body, symbolize_names: true )
object
c
puts request.env['CONTENT_TYPE']
puts request.env['content_type']
puts request.env('content_type')
puts request.env.to_yaml
request.env.to_yaml
request.env['Content-Type']
request.env
request.headers
request.header
request
headers
params
c
headers
headers['Content-Type']
c
request.body.read
request.body
c
params
q
params
q
concatenate Dir.glob('../../ax/packages/ax-appkit/src/**/*.js')
Dir.glob('../../ax/packages/ax-appkit/src/**/*.js')
c
q
headers
headers['Content-Type']
c
headers
request.body.rewind
request.body.read
headers[:content_type]
q
options
body
route
c
request
q
request.body.read
request.body
request
params
q
api_vars
c
$SESSION_TIMEOUT_MINUTES.to_f * 60
$SESSION_TIMEOUT_MINUTES
q
`git -C '#{ tmp_repo_path }' branch`.present?
`git -C '#{ tmp_repo_path }' branch`.any?
`git -C '#{ tmp_repo_path }' branch` || 111
`git -C '#{ tmp_repo_path }' branch`
c
`git -C '#{ Dir.glob( "#{ tmp }/*" )[0] }' branch`
Dir.glob( "#{ tmp }/*" )[0]
tmp
q
repo.git 'branch'
git_branch
git_branch.match(/\*\s*(\w+)/)[1]
q
refs
q
refs
c
status
e
c
eresult
e.result
e
c
branch.current
branch
command
result
c
git 'diff origin..HEAD'
git 'status --porcelain'
q
c
response.content_type
response.each_header.to_h
response['Cache-Control']
puts response.headerresponse['Cache-Control']
puts response.headers
puts response.header.methods.sort
response.header.methods
response.header
puts response.methods.sort
puts response.methods
response.methods
response
q
request.content_type
request.header
request.headers
request.contentType
request
content_type
c
puts JSON.parse( @body, symbolize_names: true )[:error_object].to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object].to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object] || {}
@headers[:content_type]
c
e
c
q
payload
c
2
puts self.backtrace
c
puts self.backtrace
c
puts self.backtrace
c
puts self.backtrace
self.backtrace
self
where
c
message
c
2
where
c
1
c
message
c
message
c
where
message
c
message
c
message
c
Helpers
@headers[:content_type] == 'application/json'
@headers[:content_type]
puts JSON.parse( @body, symbolize_names: true ).to_yaml
JSON.parse( @body, symbolize_names: true ).to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object][:error_msg]
JSON.parse( @body, symbolize_names: true )[:error_object].keys
JSON.parse( @body, symbolize_names: true )[:error_object]
JSON.parse( @body, symbolize_names: true )
object
@body
message
q
e.message
e.methods
e
q
object
object.dig :software
object.dig :software, :base
object.dig :software, :base, :type_path
q
service.blueprint
service.blueprint.type
q
type
q
down
up
where
help
where
type
q
c
git_branch.match(/\*\s*(\w+)/)[1]
c
git_branch.match(/\*\s*(\w+)/)[1]
c
git_branch.match(/\*\s*(\w+)/)[1]
c
q
Namespace.lookup( namespace ).definitions.lookup( type ).object
                object
