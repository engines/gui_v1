c
e
c
e
c
e
c
e
c
e
c
e
c
e
c
e
serializedEvent
c
e
c
request.content_type
c
params
c
{}.merge({a:1})
{}.merge!({a:1})
params.class
params
params.merge(JSON.parse(request.body.read))
params
params.merge(JSON.parse(request.body.read))
params
{}
c
request.body
request
rerequestrre
c
cc
c
e
c
params
c
puts JSON.parse( e.http_body, symbolize_names: true ).to_yaml
puts JSON.parse( e.http_body, symbolize_names: true, 2 )
puts JSON.parse( e.http_body, symbolize_names: true )
JSON.parse( e.http_body, symbolize_names: true )
e.http_body
e.message
e
c
puts e.to_yaml
e
c
e
c
e
c
e
c
e
c
e
c
e.message
e
c
params[:splat][0]
params[:splat][0[
params[:splat]
binding_path
filename
c
params
c
e.message
e.full_message
e.message
e.to_s
e
c
puts caller(0)
e
c
puts caller(0)
caller(0)
help
where
c
e.to_s
e
where
c
where
c
where
help
where
e
c
@engines.get('/system/status', timeout: 5)
c
params[:filepond][:tempfile].read
params[:filepond][:tempfile]
params[:filepond]
params
c
request.body.read
request.body
params
c
@engines.get('/system/keys/user/engines/generate').body
c
@engines.get('/system/keys/user/engines/generate').body
@engines.get('/system/keys/user/engines/generate')
q
c
e
c
request.path_info == '/reconnected' && request.request_method == 'GET'
c
request.path_info == '/session' && request.request_method == 'POST'
request.path_info
c
puts e.full_message
e.full_message
e
c
e
c
q
puts e.full_message
e.full_message
e.methods
e.class
e
c
api_call( route, method: :post, **options )
options
q
request.content_length
request.content_type
request.body
puts request.to_yaml
request
params
q
params
request.content_type
request
params
c
params
c
params
puts self.methods.sort
self.methods
self
query
params.to_json
params
@engines.delete(path)
q
@engines.delete(path, '{}')
@engines.delete(path)
q
@engines.delete(path, '{}')
@engines.delete(path)
params.to_json
c
puts request.to_yaml
puts request.methods.sort
request.methods
request
c
JSON.parse( @body, symbolize_names: true )
object
c
puts request.env['CONTENT_TYPE']
puts request.env['content_type']
puts request.env('content_type')
puts request.env.to_yaml
request.env.to_yaml
request.env['Content-Type']
request.env
request.headers
request.header
request
headers
params
c
headers
headers['Content-Type']
c
request.body.read
request.body
c
params
q
params
q
concatenate Dir.glob('../../ax/packages/ax-appkit/src/**/*.js')
Dir.glob('../../ax/packages/ax-appkit/src/**/*.js')
c
q
headers
headers['Content-Type']
c
headers
request.body.rewind
request.body.read
headers[:content_type]
q
options
body
route
c
request
q
request.body.read
request.body
request
params
q
api_vars
c
$SESSION_TIMEOUT_MINUTES.to_f * 60
$SESSION_TIMEOUT_MINUTES
q
`git -C '#{ tmp_repo_path }' branch`.present?
`git -C '#{ tmp_repo_path }' branch`.any?
`git -C '#{ tmp_repo_path }' branch` || 111
`git -C '#{ tmp_repo_path }' branch`
c
`git -C '#{ Dir.glob( "#{ tmp }/*" )[0] }' branch`
Dir.glob( "#{ tmp }/*" )[0]
tmp
q
repo.git 'branch'
git_branch
git_branch.match(/\*\s*(\w+)/)[1]
q
refs
q
refs
c
status
e
c
eresult
e.result
e
c
branch.current
branch
