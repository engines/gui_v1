q
Dir.glob( "#{ path }/*" )
path
c
path
q
namespace.services.to_h
namespace.services
q
owner.project_dir
owner.repo_dir
q
owner.path
c
owner.path
c
owner.path
q
owner
owner.path
"#{ owner.path }/#{ owner.name }"
c
"#{ owner.path }/#{ owner.name }"
c
"#{ owner.path }/#{ owner.name }"
owner
c
project_dir
c
q
c
params
q
project_dir
q
puts settings.methods.sort
settings.methods.sort
settings.methods
settings
quit
request.body.read
request.body
params
quit
params
quit
params
quit
params[:blueprint]
params
exit
ENV['SESSION_TIMEOUT_MINUTES']
c
Home.new.to_json
c
 @engines.get( "/containers/#{ typeForRoute }/#{ name }/status" ).body
 @engines.get( "/containers/#{ typeForRoute }/#{ name }/status" )
statusJSON
c
e
c
JSON.parse( '{"status":"untag","id":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf","Type":"container","Action":"untag","Actor":{"ID":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf","Attributes":{"name":"sha256:4cc7bf073be8924402d7d533a4318f4a2ff14d0e710d0504add0b0c927b542cf"}},"time":1575164190,"timeNano":1575164190353597993,"container_name":null,"container_type":null,"state":"untag"}' )
e
c
puts JSON.pretty_generate params[:api_vars]
c
puts JSON.pretty_generate params[:api_vars]
puts params[:api_vars].to_yaml
c
puts params[:api_vars].to_yaml
params[:api_vars]
c
params[:api_vars]
c
puts params[:api_vars].to_yaml
puts params[:api_vars]
params[:api_vars]
c
params
c
puts JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body )
e.http_body
e.response.message
e.response
c
e.class
e.is_a? RestClient
e.is_as? RestClient
e
c
e.message
e
ee
e
q
JSON.parse( e.http_body ).to_yaml
puts JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body ).to_yaml
JSON.parse( e.http_body )
e.http_body
e.http_headers
e.http_body
puts e.methods.sort
e.http_code.class
e.http_code
puts e.http_code
puts e.methods.sort
e.response.http_statu
e.response.http_status
e.response.status
e.response.headers
JSON.parse( e.response.body )
e.response.headers[:content_type]
e.response.headers
e.response[:headers]
e.response.body
puts e.response.methods.sort
puts e.methods.response.sort
e.response
e.to_json
puts e.methods.sort
e.message
e.class
e
c
e
c
q
c
@current_user
c
to_h.each_with_index.select { |view,i| view[:name] == name }.map(&:last)[0]
to_h.each_with_index.select { |view,i| view[:name] == name }.map &:last
c
to_h[1]['name']
to_h[1][:name]
to_h[1]
to_h.find do |view| view[:name]  end
to_h.find do |view| view[:name] == name end
to_h
c
id
path
project_dir
c
Application.active
Service.active
Service.count
Namespace.to_h
            }Namespace.to_h
              # git_user: @settings.git_username
              namespaces: Namespace.to_h,
              },
                active: Service.active,
                count: Service.count,
              services: {
              },
                active: Application.active,
                count: Application.count,
              applications: {
              public_key: @current_user.public_key,
{
Application.count
@current_user.public_key
c
params
c
status
status = 'Up to date' if status == ''
`git -C '#{ path }' status -s`
c
status
c
name
namespace ? "#{ namespace }/#{ name }" : name
namespace
c
"#{ destination }/#{ id }"
c
"#{ destination }/#{ id }"
c
"#{ destination }/#{ id }"
id
destination
c
puts caller(0)
params
c
destination
"#{ destination }/#{ id }"
c
repo.file 'blueprint.json'
c
repo.file '/blueprint.json'
repo.file 'blueprint.json'
c
path
Dir.glob( "#{path}/*" )
c
File.exist? "#{ destination }/#{ id }/w"
File.exist? "#{ destination }/#{ id }"
e
c
Digest::MD5.hexdigest(url)
Digest::MD5.hexdigest(url+'1').to_s
Digest::MD5.hexdigest(url).to_s
Digest::MD5.hexdigest(url).to_i(32)s
Digest::MD5.hexdigest(url).to_i(32)
Digest::MD5.hexdigest(url).to_i(64)
Digest::MD5.hexdigest(url).to_i(32)
Digest::MD5.hexdigest(url).to_i(16)
Digest::MD5.hexdigest(url).to_i(8)
Digest::MD5.hexdigest(url).to_i(64)
Digest::MD5.hexdigest(url).to_i
Digest::MD5.hexdigest(url).to_i(16)
Digest
c
request.path_info
request
params
params[:namespace_id]
c
namespace
namespace.id
all
to_h
c
"#{ owner.path }/#{ owner.name }"File.read 
"#{ owner.path }/#{ owner.name }"
c
Dir.glob( "#{path}/*" )
Dir.entries( "#{path}/*" )
Dir.entries( path )
c
name
all[0].name
all[0]
all.length
all
r
c
namespace_id
c
@namespace_name
c
puts caller(0)
c
all[0].name
all[0]
all.count
all
c
id
c
