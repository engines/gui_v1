q
c
response.content_type
response.each_header.to_h
response['Cache-Control']
puts response.headerresponse['Cache-Control']
puts response.headers
puts response.header.methods.sort
response.header.methods
response.header
puts response.methods.sort
puts response.methods
response.methods
response
q
request.content_type
request.header
request.headers
request.contentType
request
content_type
c
puts JSON.parse( @body, symbolize_names: true )[:error_object].to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object].to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object] || {}
@headers[:content_type]
c
e
c
q
payload
c
2
puts self.backtrace
c
puts self.backtrace
c
puts self.backtrace
c
puts self.backtrace
self.backtrace
self
where
c
message
c
2
where
c
1
c
message
c
message
c
where
message
c
message
c
message
c
Helpers
@headers[:content_type] == 'application/json'
@headers[:content_type]
puts JSON.parse( @body, symbolize_names: true ).to_yaml
JSON.parse( @body, symbolize_names: true ).to_yaml
JSON.parse( @body, symbolize_names: true )[:error_object][:error_msg]
JSON.parse( @body, symbolize_names: true )[:error_object].keys
JSON.parse( @body, symbolize_names: true )[:error_object]
JSON.parse( @body, symbolize_names: true )
object
@body
message
q
e.message
e.methods
e
q
object
object.dig :software
object.dig :software, :base
object.dig :software, :base, :type_path
q
service.blueprint
service.blueprint.type
q
type
q
down
up
where
help
where
type
q
c
git_branch.match(/\*\s*(\w+)/)[1]
c
git_branch.match(/\*\s*(\w+)/)[1]
c
git_branch.match(/\*\s*(\w+)/)[1]
c
q
Namespace.lookup( namespace ).definitions.lookup( type ).object
                object
                definitions.lookup( type ).
Namespace.lookup( namespace ).
q
2
params
Consumables.type( params[:namespace], params[:type] )
q
Namespace.lookup( namespace ).definitions.lookup( type ).object[:consumer_params].values
Namespace.lookup( namespace ).definitions.lookup( type ).object[:consumer_params]
Namespace.lookup( namespace ).definitions.lookup( type ).object
q
Namespace.lookup( namespace ).definitions.lookup( type ).object
q
c
definition.type
definition
c
"#{ path }/#{ filepath }"
quit
"#{ workspace.repo.path }/#{ type }"
workspace.repo.path
workspace.repo
workspace
repo
"#{ path }/#{ type }"
type
c
type
q
object.dig :software
object
q
Error::JsonParse.new( e.message )
q
JSON.parse "{a}"
c
service.type
service.namespace.workspace.repo.read 'auth/auth.yaml'
c
service.namespace.workspace.repo.read 'auth/auth.yaml'
service.namespace.workspace.repo
service.namespace.workspace
service.workspace
service
c
parent_dir
q
stderr
stdout
q
puts caller(0) 
owner.repo_dir
c
owner.repo_dir
c
puts caller(0) 
caller(0) 
owner
owner.repo_dir
c
owner.repo_dir
c
owner.repo_dir
c
owner.repo_dir
owner
c
where
stack
backtrace
trace
owner
owner.repo_dir
c
owner.repo_dir
c
owner.repo_dir
`git -C "data/namespaces/b5b2df292e7b0a234b61abbd29545e7e/EnginesSystem" branch`
c
`git -C "data/namespaces/b5b2df292e7b0a234b61abbd29545e7e/EnginesSystem" branch`
git -C "data/namespaces/b5b2df292e7b0a234b61abbd29545e7e/EnginesSystem" branch
owner.repo_dir
c
q
params[:current]
params
c
'a'.any?
'a'.empty?
'a'.blank?
'a'.blank
'a'.length
'a'.any?
['','1'].compact
status.exitstatus
stderr
stdout
q
"".empty?
"".present?
nil||1
0||1
""||1
status.exitstatus
stdout
stderr
command
c
command
stdout
stderr
c
status.exitstatus
puts status.methods
status.success?
c
status.success?
stderr
c
stdout
q
@message
c
puts status.methods
status.code
status.exit
status
c
`git -C '#{ path }' commit -m #{ commit[:message] }`
c
params
c
params
c
params
params[:type]
q
type
q
c
entry_path
c
entry_path
c
entry_path
c
entry_path
c
entry_path
c
